AGENTUITY PLATFORM DOCUMENTATION

Reference for the Agentuity agent development platform.

OVERVIEW

Agentuity is a cloud platform for building, deploying, and managing AI agents. Ship production-ready agents in minutes, not weeks.

Key features:
- Managed infrastructure: KV storage, vector databases, object storage, SQL
- AI Gateway: Use any LLM provider (OpenAI, Anthropic, Google, etc.) with a single API key
- Full-stack: Deploy agents, APIs, and frontends together
- TypeScript-first with the Bun runtime
- Code-first configuration with auto-discovery
- Built-in observability: logging, tracing, sessions

Get started: bunx create-agentuity@latest my-project

================================================================================
CORE CONCEPTS
================================================================================

Agentuity uses a code-first approach with auto-discovery and type-safe schemas.

1. PROJECT STRUCTURE

```
my-project/
├── agentuity.json        # Minimal config (name, orgId, projectId)
├── .env                  # Environment variables
├── app.ts                # App entry point with lifecycle hooks
├── package.json
└── src/
    ├── agent/            # Agents (auto-discovered)
    │   └── chat/
    │       ├── agent.ts  # Agent logic
    │       └── eval.ts   # Evaluations (optional)
    ├── api/              # HTTP routes
    │   └── index.ts
    └── web/              # Frontend (React)
        └── App.tsx
```

Key directories:
- src/agent/ - Logic layer. Each subfolder is an agent. Auto-discovered.
- src/api/ - Transport layer. HTTP, Cron, WebSocket, SSE routes.
- src/web/ - Frontend layer. React code deployed alongside agents.

2. APPLICATION ENTRY POINT (app.ts)

```typescript
import { createApp } from '@agentuity/runtime';

export default createApp({
  cors: { origin: '*' },
  setup: async () => {
    // Initialize shared resources (DB connections, clients)
    return { db: await connectDatabase() };
  },
  shutdown: async (app) => {
    // Cleanup on shutdown
    await app.db.close();
  },
});
```

The setup return value is available via ctx.app in agents and c.var.app in routes.

3. DEFINING AGENTS (src/agent/)

Use createAgent() with StandardSchema-compatible libraries (Zod, Valibot, ArkType, @agentuity/schema).

```typescript
// src/agent/chat/agent.ts
import { createAgent } from '@agentuity/runtime';
import { z } from 'zod';
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

const agent = createAgent('Chat', {
  schema: {
    input: z.object({ message: z.string() }),
    output: z.object({ response: z.string() }),
  },
  handler: async (ctx, input) => {
    ctx.logger.info('Processing message', { message: input.message });

    const { text } = await generateText({
      model: openai('gpt-5-mini'),
      prompt: input.message,
    });

    return { response: text };
  },
});

export default agent;
```

STATE MANAGEMENT

Request State (ctx.state) - Ephemeral, cleared after response:
```typescript
ctx.state.set('temp', value);
const temp = ctx.state.get<Type>('temp');
```

Thread State (ctx.thread.state) - Persists for 1 hour of inactivity. Ideal for chat history:
```typescript
// Use push() with maxRecords for automatic sliding window
await ctx.thread.state.push('history', { role: 'user', content: input.message }, 50);
await ctx.thread.state.push('history', { role: 'assistant', content: response }, 50);

// Reading history (for AI context)
const history = (await ctx.thread.state.get<Message[]>('history')) ?? [];
```

Session State (ctx.session.state) - Request-scoped, accessible in completion events:
```typescript
ctx.session.state.set('startTime', Date.now());
```

CALLING OTHER AGENTS

```typescript
import otherAgent from '@agent/other';

// In handler:
const result = await otherAgent.run({ data: 'value' });
```

AGENT EVENTS AND LIFECYCLE

```typescript
createAgent('MyAgent', {
  schema: { /* ... */ },
  handler: async (ctx, input) => { /* ... */ },
  events: {
    onStart: async (ctx) => {
      ctx.logger.info('Agent starting');
    },
    onComplete: async (ctx, output) => {
      ctx.logger.info('Agent completed', { output });
    },
    onError: async (ctx, error) => {
      ctx.logger.error('Agent failed', { error });
    },
  },
});
```

4. EVALUATIONS (eval.ts)

Evaluations run automatically after agent execution to measure quality:

```typescript
// src/agent/chat/eval.ts
import agent from './agent';

export const relevanceEval = agent.createEval('check-relevance', {
  handler: async (ctx, input, output) => {
    const isRelevant = output.response.toLowerCase().includes(
      input.message.toLowerCase().split(' ')[0]
    );
    return {
      success: isRelevant,
      score: isRelevant ? 1.0 : 0.0,
      message: isRelevant ? 'Response is relevant' : 'Response may be off-topic'
    };
  },
});

export const lengthEval = agent.createEval('check-length', {
  handler: async (ctx, input, output) => {
    const score = Math.min(output.response.length / 100, 1.0);
    return { success: score > 0.5, score };
  },
});
```

Results appear in the Agentuity Console under the session.

5. DEFINING ROUTES (src/api/)

Routes use Hono-style syntax. Import agents and invoke via agent.run().

```typescript
// src/api/index.ts
import { createRouter } from '@agentuity/runtime';
import chat from '@agent/chat';

const router = createRouter();

// Simple endpoint
router.get('/health', (c) => c.json({ status: 'ok' }));

// Agent-backed endpoint with validation
router.post('/chat', chat.validator(), async (c) => {
  const data = c.req.valid('json'); // Fully typed from agent schema
  const result = await chat.run(data);
  return c.json(result);
});

export default router;
```

MIDDLEWARE

```typescript
import { createRouter, createMiddleware } from '@agentuity/runtime';

const authMiddleware = createMiddleware(async (c, next) => {
  const token = c.req.header('Authorization');
  if (!token) {
    return c.json({ error: 'Unauthorized' }, 401);
  }
  c.set('userId', await validateToken(token));
  await next();
});

router.use('/api/*', authMiddleware);
```

CRON ROUTES

```typescript
// Runs every day at midnight UTC
router.cron('0 0 * * *', async (c) => {
  c.var.logger.info('Running daily cleanup');
  await cleanupTask.run({});
});
```

WEBSOCKET ROUTES

```typescript
router.websocket('/ws/chat', {
  onOpen: (ws, c) => {
    c.var.logger.info('Client connected');
  },
  onMessage: async (ws, message, c) => {
    const data = JSON.parse(message);
    const result = await chat.run(data);
    ws.send(JSON.stringify(result));
  },
  onClose: (ws, c) => {
    c.var.logger.info('Client disconnected');
  },
});
```

SERVER-SENT EVENTS (SSE)

```typescript
router.sse('/events', async (c, stream) => {
  for await (const event of getEvents()) {
    await stream.write({ data: JSON.stringify(event) });
  }
});
```

EMAIL AND SMS ROUTES

```typescript
// Email trigger
router.email(async (c) => {
  const email = c.req.email;
  c.var.logger.info('Email received', { from: email.from, subject: email.subject });
  await emailProcessor.run({ email });
});

// SMS trigger
router.sms(async (c) => {
  const sms = c.req.sms;
  c.var.logger.info('SMS received', { from: sms.from, body: sms.body });
  await smsProcessor.run({ sms });
});
```

6. MANAGED SERVICES

KEY-VALUE STORAGE (ctx.kv)

Fast, namespaced storage with TTL support:

```typescript
// Set with optional TTL (seconds)
await ctx.kv.set('users', 'user-123', { name: 'Alice' }, { ttl: 3600 });

// Get
const user = await ctx.kv.get<User>('users', 'user-123');

// Search by prefix
const matches = await ctx.kv.search('users', 'user-');

// List all keys
const keys = await ctx.kv.getKeys('users');

// Delete
await ctx.kv.delete('users', 'user-123');
```

VECTOR STORAGE (ctx.vector)

Semantic search and RAG:

```typescript
// Upsert documents (auto-embedded)
await ctx.vector.upsert('documents', {
  key: 'doc-1',
  document: 'This is the document text to embed',
  metadata: { category: 'tech', author: 'Alice' },
});

// Search
const results = await ctx.vector.search('documents', {
  query: 'search query text',
  limit: 5,
  similarity: 0.7, // minimum similarity threshold
  metadata: { category: 'tech' }, // filter by metadata
});

// Get specific document
const doc = await ctx.vector.get('documents', 'doc-1');

// Delete
await ctx.vector.delete('documents', 'doc-1');
```

DURABLE STREAMS (ctx.stream)

Write-once, read-many persistent streams with public URLs:

```typescript
const stream = await ctx.stream.create({
  contentType: 'text/csv',
  filename: 'export.csv'
});

await stream.write('name,email\n');
await stream.write('Alice,alice@example.com\n');
await stream.close();

// Get public URL for download
const url = stream.url;
```

OBJECT STORAGE (Bun S3)

```typescript
import { s3 } from 'bun';

const bucket = s3('my-bucket');

// Write
await bucket.write('path/to/file.json', JSON.stringify(data));

// Read
const content = await bucket.file('path/to/file.json').text();

// Delete
await bucket.delete('path/to/file.json');

// List
const files = await bucket.list({ prefix: 'path/' });
```

DATABASE (Bun SQL)

```typescript
import { sql } from 'bun';

// Query
const users = await sql`SELECT * FROM users WHERE active = ${true}`;

// Insert
await sql`INSERT INTO users (name, email) VALUES (${name}, ${email})`;

// Transactions
await sql.transaction(async (tx) => {
  await tx`UPDATE accounts SET balance = balance - ${amount} WHERE id = ${from}`;
  await tx`UPDATE accounts SET balance = balance + ${amount} WHERE id = ${to}`;
});
```

AI GATEWAY

Use any AI model from any provider with a single API key. No juggling multiple accounts - the gateway handles authentication, tracks usage, and lets you switch models without code changes.

```typescript
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

// Uses AI Gateway automatically if OPENAI_API_KEY not set
const { text } = await generateText({
  model: openai('gpt-5-mini'),
  prompt: 'Hello!',
});
```

Supported providers: OpenAI, Anthropic, Google, Groq, and more.

7. OBSERVABILITY

LOGGING

```typescript
// In agents
ctx.logger.info('Processing', { key: 'value' });
ctx.logger.warn('Warning message');
ctx.logger.error('Error occurred', { error });

// In routes
c.var.logger.info('Request received');
```

TRACING

```typescript
const span = ctx.tracer.startSpan('external-api-call');
try {
  const result = await fetch('https://api.example.com');
  span.end();
  return result;
} catch (error) {
  span.recordException(error);
  span.end();
  throw error;
}
```

SESSION IDS

Every request gets a unique session ID (sess_...) for debugging:

```typescript
ctx.logger.info('Session', { sessionId: ctx.sessionId });
```

Thread IDs (thrd_...) track conversation context across requests.

8. FRONTEND INTEGRATION (src/web/)

PROVIDER SETUP

```tsx
// src/web/App.tsx
import { AgentuityProvider } from '@agentuity/react';

export default function App() {
  return (
    <AgentuityProvider>
      <MyComponent />
    </AgentuityProvider>
  );
}
```

useAPI HOOK

```tsx
import { useAPI } from '@agentuity/react';

function ChatForm() {
  const { invoke, isLoading, data, error } = useAPI('POST /chat');

  const handleSubmit = async (message: string) => {
    await invoke({ message });
  };

  return (
    <div>
      <button onClick={() => handleSubmit('Hello')} disabled={isLoading}>
        {isLoading ? 'Sending...' : 'Send'}
      </button>
      {data && <p>{data.response}</p>}
      {error && <p className="error">{error.message}</p>}
    </div>
  );
}
```

useWebsocket HOOK

```tsx
import { useWebsocket } from '@agentuity/react';

function RealtimeChat() {
  const { send, messages, isConnected } = useWebsocket('/ws/chat');

  return (
    <div>
      <p>Status: {isConnected ? 'Connected' : 'Disconnected'}</p>
      {messages.map((msg, i) => <p key={i}>{msg.data}</p>)}
      <button onClick={() => send({ message: 'Hello' })}>Send</button>
    </div>
  );
}
```

useEventStream HOOK

```tsx
import { useEventStream } from '@agentuity/react';

function LiveUpdates() {
  const { data, isConnected } = useEventStream('/events');

  return (
    <div>
      <p>Latest: {data?.event}</p>
    </div>
  );
}
```

9. CLI COMMANDS

```
agentuity dev                      - Start dev server with hot-reload, Workbench UI, and public tunnel
agentuity build                    - Build for deployment
agentuity deploy                   - Deploy to Agentuity Cloud
agentuity cloud session logs <id>  - View session logs
agentuity ssh                      - SSH into running container
agentuity env set KEY=value        - Set environment variable
agentuity env list                 - List environment variables
```

DEVELOPMENT

```bash
# Start dev server (default port 3500)
agentuity dev

# With custom port
agentuity dev --port 4000

# Without public tunnel
agentuity dev --no-tunnel
```

The Workbench UI is available at http://localhost:3500/workbench for testing agents interactively.

10. CONFIGURATION

agentuity.json

```json
{
  "name": "my-project",
  "orgId": "org_xxx",
  "projectId": "proj_xxx"
}
```

ENVIRONMENT VARIABLES

```bash
# .env
OPENAI_API_KEY=sk-...          # Optional: uses AI Gateway if not set
DATABASE_URL=postgres://...
MY_SECRET=value
```

Access in code:
```typescript
const secret = process.env.MY_SECRET;
// or
const secret = Bun.env.MY_SECRET;
```

================================================================================
FREQUENTLY ASKED QUESTIONS
================================================================================

AGENT VS ROUTE: WHEN TO USE EACH

Use Agents for:
- Complex business logic
- AI/LLM operations
- Operations needing state management
- Code that needs evaluations
- Reusable logic called from multiple routes

Use Routes (without agents) for:
- Simple CRUD operations
- Health checks
- Webhook receivers with simple logic
- Static responses
- Proxying to external services

SHARING DATA BETWEEN REQUESTS

- Same request: Use ctx.state
- Same conversation (chat): Use ctx.thread.state (persists 1 hour)
- Across all requests: Use ctx.kv or database

DEBUGGING AGENTS

1. Use ctx.logger for structured logging
2. Check logs in Agentuity Console by session ID
3. Use Workbench UI locally (/workbench)
4. Use ctx.tracer for performance tracing
5. SSH into container: agentuity ssh

CALLING EXTERNAL APIS

```typescript
const response = await fetch('https://api.example.com/data', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ key: 'value' }),
});
const data = await response.json();
```

ERROR HANDLING

```typescript
createAgent('MyAgent', {
  schema: { /* ... */ },
  handler: async (ctx, input) => {
    try {
      const result = await riskyOperation();
      return { success: true, result };
    } catch (error) {
      ctx.logger.error('Operation failed', { error });
      throw error; // Or return error response
    }
  },
  events: {
    onError: async (ctx, error) => {
      // Handle error (alerting, cleanup, etc.)
    },
  },
});
```

DEPLOYMENT

```bash
# Build and deploy
agentuity deploy

# Or step by step
agentuity build
agentuity deploy --bundle ./dist/bundle.zip
```

ENVIRONMENT VARIABLES

```bash
# Set variable
agentuity env set MY_KEY=my_value

# List variables
agentuity env list

# Use in code
const value = process.env.MY_KEY;
```

USING CUSTOM LLM API KEYS

Set the provider's API key in environment variables:

```bash
agentuity env set OPENAI_API_KEY=sk-...
agentuity env set ANTHROPIC_API_KEY=sk-ant-...
```

If not set, requests automatically route through Agentuity's AI Gateway with unified billing.

STREAMING RESPONSES

```typescript
// In agent
createAgent('StreamingAgent', {
  handler: async (ctx, input) => {
    const { textStream } = await streamText({
      model: openai('gpt-5-mini'),
      prompt: input.message,
    });

    return textStream; // Return stream directly
  },
});

// In route (SSE)
router.sse('/stream', async (c, stream) => {
  for await (const chunk of generateChunks()) {
    await stream.write({ data: chunk });
  }
});
```

AUTHENTICATION

```typescript
// Middleware approach
const authMiddleware = createMiddleware(async (c, next) => {
  const token = c.req.header('Authorization')?.replace('Bearer ', '');
  if (!token) {
    return c.json({ error: 'Unauthorized' }, 401);
  }

  try {
    const user = await verifyToken(token);
    c.set('user', user);
    await next();
  } catch {
    return c.json({ error: 'Invalid token' }, 401);
  }
});

router.use('/api/*', authMiddleware);
```

SUPPORTED SCHEMA LIBRARIES

Any StandardSchema-compatible library:
- @agentuity/schema (built-in, no dependencies)
- Zod
- Valibot
- ArkType

```typescript
// @agentuity/schema
import { s } from '@agentuity/schema';
const schema = s.object({ name: s.string() });

// Zod
import { z } from 'zod';
const schema = z.object({ name: z.string() });

// Valibot
import * as v from 'valibot';
const schema = v.object({ name: v.string() });
```
